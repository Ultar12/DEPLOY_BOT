document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('deploy-form');
    const appNameInput = document.getElementById('appName');
    const sessionIdInput = document.getElementById('sessionId');
    const autoStatusViewRadios = document.querySelectorAll('input[name="autoStatusView"]');
    const deployKeyInput = document.getElementById('deployKey'); // <-- NEW
    const nameStatus = document.getElementById('name-status');
    const submitButton = document.getElementById('submit-button');
    const paystackButton = document.getElementById('paystack-button');
    const errorMessage = document.getElementById('error-message');
    const successMessage = document.getElementById('success-message');

    let botType = 'levanter';
    let userId = '';
    const appNameRegex = /^[a-z0-9-]+$/;
    let isAppNameAvailable = false;

    const params = new URLSearchParams(window.location.search);
    userId = params.get('user_id');
    botType = params.get('bot_type') || botType;

    const displayMessage = (type, text) => {
        errorMessage.textContent = '';
        successMessage.textContent = '';
        if (type === 'error') {
            errorMessage.textContent = text;
        } else if (type === 'success') {
            successMessage.textContent = text;
        }
    };

    const toggleButtons = () => {
        const isSessionIdFilled = sessionIdInput.value.trim().length > 0;
        const isAutoStatusSelected = Array.from(autoStatusViewRadios).some(radio => radio.checked);
        const isDeployKeyFilled = deployKeyInput.value.trim().length > 0; // <-- NEW
        
        const canDeploy = isAppNameAvailable && isSessionIdFilled && isAutoStatusSelected;
        
        // Enable Deploy button only if all fields are valid AND a key is provided
        submitButton.disabled = !(canDeploy && isDeployKeyFilled);
        
        // Enable Paystack button only if all fields are valid AND no key is provided
        paystackButton.disabled = !(canDeploy && !isDeployKeyFilled);
    };

    const debounce = (func, delay) => {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    };

    const checkAppNameAvailability = async (appName) => {
        isAppNameAvailable = false;
        toggleButtons();

        if (appName.length > 30) {
            nameStatus.textContent = 'Name is too long (max 30 chars).';
            nameStatus.className = 'status-message taken';
            return;
        }
        if (!appNameRegex.test(appName)) {
            nameStatus.textContent = 'Invalid format. Use lowercase letters, numbers, and hyphens.';
            nameStatus.className = 'status-message taken';
            return;
        }

        nameStatus.textContent = 'Checking...';
        nameStatus.className = 'status-message';
        
        try {
            const response = await fetch(`/api/check-app-name/${appName}`);
            const data = await response.json();

            if (data.available) {
                nameStatus.textContent = 'Available!';
                nameStatus.className = 'status-message available';
                isAppNameAvailable = true;
            } else {
                nameStatus.textContent = 'Not Available';
                nameStatus.className = 'status-message taken';
                isAppNameAvailable = false;
            }
        } catch (error) {
            console.error('Error checking app name:', error);
            nameStatus.textContent = 'Error checking name';
            nameStatus.className = 'status-message error';
            isAppNameAvailable = false;
        } finally {
            toggleButtons();
        }
    };

    const debouncedCheckAppName = debounce(checkAppNameAvailability, 500);

    appNameInput.addEventListener('input', () => {
        const appName = appNameInput.value.trim();
        nameStatus.textContent = '';
        if (appName.length >= 3) {
            debouncedCheckAppName(appName);
        } else if (appName.length > 0) {
            nameStatus.textContent = 'Enter at least 3 characters.';
            nameStatus.className = 'status-message';
        }
        isAppNameAvailable = false;
        toggleButtons();
    });
    
    // Listen for changes in other fields to enable/disable button
    sessionIdInput.addEventListener('input', toggleButtons);
    autoStatusViewRadios.forEach(radio => radio.addEventListener('change', toggleButtons));
    deployKeyInput.addEventListener('input', toggleButtons); // <-- NEW

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        displayMessage(null, '');
        submitButton.disabled = true;
        submitButton.textContent = 'Deploying...';

        const formData = new FormData(form);
        const data = {
            userId: userId,
            botType: botType,
            appName: formData.get('appName'),
            sessionId: formData.get('sessionId'),
            autoStatusView: formData.get('autoStatusView'),
            deployKey: formData.get('deployKey') // <-- NEW
        };

        try {
            const response = await fetch('/api/deploy', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });

            const result = await response.json();
            if (result.success) {
                displayMessage('success', result.message);
                Telegram.WebApp.showAlert('Deployment started! Check the bot for updates.');
                Telegram.WebApp.close();
            } else {
                displayMessage('error', result.message);
                submitButton.disabled = false;
                submitButton.textContent = 'Deploy Bot ðŸš€';
            }
        } catch (error) {
            console.error('Error submitting deployment:', error);
            displayMessage('error', 'Failed to connect to server.');
            submitButton.disabled = false;
            submitButton.textContent = 'Deploy Bot ðŸš€';
        }
    });

    paystackButton.addEventListener('click', async () => {
        displayMessage(null, '');
        submitButton.disabled = true;
        paystackButton.disabled = true;
        paystackButton.textContent = 'Processing...';

        const formData = new FormData(form);
        const data = {
            userId: userId,
            botType: botType,
            appName: formData.get('appName'),
            sessionId: formData.get('sessionId'),
            autoStatusView: formData.get('autoStatusView')
        };

        try {
            const response = await fetch('/api/paystack-init', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (result.success) {
                Telegram.WebApp.showAlert('Redirecting to Paystack for payment...');
                window.location.href = result.authorization_url; // Redirect the user to pay
            } else {
                displayMessage('error', result.message);
                paystackButton.disabled = false;
                paystackButton.textContent = 'Pay with Paystack';
            }
        } catch (error) {
            console.error('Paystack initiation error:', error);
            displayMessage('error', 'Failed to connect to server for payment.');
            paystackButton.disabled = false;
            paystackButton.textContent = 'Pay with Paystack';
        }
    });
});
