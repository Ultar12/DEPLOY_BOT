document.addEventListener('DOMContentLoaded', () => {
    try {
        console.log("--- SCRIPT: DOMContentLoaded event fired. Initializing Mini App. ---");
        const form = document.getElementById('deploy-form');
        const appNameInput = document.getElementById('appName');
        const sessionIdInput = document.getElementById('sessionId');
        const autoStatusViewRadios = document.querySelectorAll('input[name="autoStatusView"]');
        const deployKeyInput = document.getElementById('deployKey');
        const nameStatus = document.getElementById('name-status');
        const submitButton = document.getElementById('submit-button');
        const payButton = document.getElementById('pay-button');
        const statusButton = document.getElementById('status-button');
        const errorMessage = document.getElementById('error-message');
        const successMessage = document.getElementById('success-message');
        const emailModal = document.getElementById('email-modal');
        const closeButton = document.querySelector('.close-button');
        const modalPayButton = document.getElementById('modal-pay-button');
        const paymentEmailInput = document.getElementById('paymentEmail');
        const botTypeButtons = document.querySelectorAll('.bot-type-group .btn');
        
        let botType = 'levanter'; // Default bot type
        const appNameRegex = /^[a-z0-9-]+$/;
        let isAppNameAvailable = false;
        let isCheckingAppName = false;

        if (typeof window.Telegram === 'undefined' || typeof window.Telegram.WebApp === 'undefined') {
            console.error('Telegram WebApp object not found. This script must run inside a Telegram Mini App.');
            displayMessage('error', 'Mini App is not running in a valid environment.');
            return;
        }

        window.Telegram.WebApp.ready();

        const displayMessage = (type, text) => {
            errorMessage.textContent = '';
            successMessage.textContent = '';
            if (type === 'error') {
                errorMessage.textContent = text;
            } else if (type === 'success') {
                successMessage.textContent = text;
            }
        };

        const toggleButtons = () => {
            const isSessionIdFilled = sessionIdInput.value.trim().length > 0;
            const isAutoStatusSelected = Array.from(autoStatusViewRadios).some(radio => radio.checked);
            const isDeployKeyFilled = deployKeyInput.value.trim().length > 0;
            
            const canProceed = isAppNameAvailable && isSessionIdFilled && isAutoStatusSelected;
            
            if (isCheckingAppName) {
                submitButton.disabled = true;
                payButton.disabled = true;
                return;
            }
            
            // Enable/disable and style buttons based on validation
            if (canProceed && isDeployKeyFilled) {
                submitButton.disabled = false;
                submitButton.classList.add('green');
                submitButton.classList.remove('red');
                payButton.disabled = true;
                payButton.classList.remove('green', 'red');
            } else if (canProceed && !isDeployKeyFilled) {
                payButton.disabled = false;
                payButton.classList.add('green');
                payButton.classList.remove('red');
                submitButton.disabled = true;
                submitButton.classList.remove('green', 'red');
            } else {
                submitButton.disabled = true;
                payButton.disabled = true;
                submitButton.classList.add('red');
                submitButton.classList.remove('green');
                payButton.classList.add('red');
                payButton.classList.remove('green');
            }

            // Set button text
            payButton.textContent = payButton.disabled ? 'Pay' : 'Pay â‚¦1500';
            submitButton.textContent = submitButton.disabled ? 'Deploy Bot ðŸš€' : 'Deploy Bot ðŸš€';
        };

        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const checkAppNameAvailability = async (appName) => {
            isCheckingAppName = true;
            toggleButtons();
            
            if (appName.length > 30) {
                nameStatus.textContent = 'Name is too long (max 30 chars).';
                nameStatus.className = 'status-message taken';
                isAppNameAvailable = false;
                isCheckingAppName = false;
                toggleButtons();
                return;
            }
            if (!appNameRegex.test(appName)) {
                nameStatus.textContent = 'Invalid format. Use lowercase letters, numbers, and hyphens.';
                nameStatus.className = 'status-message taken';
                isAppNameAvailable = false;
                isCheckingAppName = false;
                toggleButtons();
                return;
            }

            nameStatus.textContent = 'Checking...';
            nameStatus.className = 'status-message';
            
            try {
                const response = await fetch(`/miniapp/api/check-app-name/${appName}`, {
                     headers: { 'X-Telegram-Init-Data': window.Telegram.WebApp.initData }
                });
                const data = await response.json();

                if (response.status === 401) {
                     nameStatus.textContent = 'Auth error. Reload Mini App.';
                     nameStatus.className = 'status-message error';
                } else if (data.available) {
                    nameStatus.textContent = 'Available!';
                    nameStatus.className = 'status-message available';
                    isAppNameAvailable = true;
                } else {
                    nameStatus.textContent = 'Not Available';
                    nameStatus.className = 'status-message taken';
                    isAppNameAvailable = false;
                }
            } catch (error) {
                console.error('Error checking app name:', error);
                nameStatus.textContent = 'Error: API not reachable.';
                nameStatus.className = 'status-message error';
                isAppNameAvailable = false;
            } finally {
                isCheckingAppName = false;
                toggleButtons();
            }
        };

        const debouncedCheckAppName = debounce(checkAppNameAvailability, 500);

        appNameInput.addEventListener('input', () => {
            const appName = appNameInput.value.trim();
            isAppNameAvailable = false;
            nameStatus.textContent = '';
            if (appName.length >= 3) {
                debouncedCheckAppName(appName);
            } else if (appName.length > 0) {
                nameStatus.textContent = 'Enter at least 3 characters.';
                nameStatus.className = 'status-message';
            } else {
                nameStatus.textContent = '';
            }
            toggleButtons();
        });
        
        sessionIdInput.addEventListener('input', toggleButtons);
        autoStatusViewRadios.forEach(radio => radio.addEventListener('change', toggleButtons));
        deployKeyInput.addEventListener('input', toggleButtons);

        botTypeButtons.forEach(button => {
            button.addEventListener('click', () => {
                botTypeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                botType = button.dataset.botType;
            });
        });

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (!deployKeyInput.value.trim()) {
                return; // Prevent form submission if deploy key is empty
            }

            displayMessage(null, '');
            submitButton.disabled = true;
            submitButton.textContent = 'Deploying...';
            submitButton.classList.add('btn-loading');

            const formData = new FormData(form);
            const data = {
                botType: botType,
                appName: formData.get('appName'),
                sessionId: formData.get('sessionId'),
                autoStatusView: formData.get('autoStatusView') === 'true',
                deployKey: formData.get('deployKey')
            };

            try {
                const response = await fetch('/miniapp/api/deploy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Telegram-Init-Data': window.Telegram.WebApp.initData
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                if (result.success) {
                    displayMessage('success', result.message);
                    window.Telegram.WebApp.showAlert('Deployment started! Check the bot for updates.');
                    window.Telegram.WebApp.close();
                } else {
                    displayMessage('error', result.message);
                }
            } catch (error) {
                console.error('Error submitting deployment:', error);
                displayMessage('error', 'Failed to connect to server.');
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Deploy Bot ðŸš€';
                submitButton.classList.remove('btn-loading');
                toggleButtons();
            }
        });

        payButton.addEventListener('click', async () => {
            console.log('--- SCRIPT: Pay button clicked, showing email modal ---');
            emailModal.classList.add('show');
        });

        closeButton.addEventListener('click', () => {
            emailModal.classList.remove('show');
        });

        window.addEventListener('click', (e) => {
            if (e.target === emailModal) {
                emailModal.classList.remove('show');
            }
        });

        modalPayButton.addEventListener('click', async () => {
            const paymentEmail = paymentEmailInput.value.trim();
            if (!paymentEmail || !paymentEmail.includes('@')) {
                window.Telegram.WebApp.showAlert('Please enter a valid email.');
                return;
            }

            displayMessage(null, '');
            modalPayButton.disabled = true;
            modalPayButton.textContent = 'Processing...';
            modalPayButton.classList.add('btn-loading');

            const formData = new FormData(form);
            const data = {
                botType: botType,
                appName: formData.get('appName'),
                sessionId: formData.get('sessionId'),
                email: paymentEmail,
                autoStatusView: formData.get('autoStatusView') === 'true'
            };

            try {
                const response = await fetch('/miniapp/api/pay', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Telegram-Init-Data': window.Telegram.WebApp.initData
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();

                if (response.status === 401) {
                    displayMessage('error', 'Authentication failed. Please reload the Mini App.');
                } else if (result.success) {
                    window.Telegram.WebApp.openLink(result.paymentUrl);
                    window.Telegram.WebApp.close();
                } else {
                    displayMessage('error', result.message);
                }
            } catch (error) {
                console.error('Paystack initiation error:', error);
                displayMessage('error', 'Failed to connect to server for payment.');
            } finally {
                modalPayButton.disabled = false;
                modalPayButton.textContent = 'Pay Now';
                modalPayButton.classList.remove('btn-loading');
            }
        });

        statusButton.addEventListener('click', async () => {
            displayMessage(null, '');
            statusButton.disabled = true;
            statusButton.textContent = 'Checking...';
            statusButton.classList.add('btn-loading');
            try {
                const response = await fetch('/miniapp/health');
                const result = await response.json();
                if (response.status === 200) {
                    displayMessage('success', result.message);
                } else {
                    displayMessage('error', 'Server responded with an error.');
                }
            } catch (error) {
                console.error('Server status check error:', error);
                displayMessage('error', 'Server is not reachable. Check Render logs.');
            } finally {
                statusButton.disabled = false;
                statusButton.textContent = 'Check Server Status';
                statusButton.classList.remove('btn-loading');
            }
        });

        // Initialize button states
        toggleButtons();

    } catch (error) {
        console.error('An unhandled error occurred in the Mini App script:', error);
        window.Telegram.WebApp.showAlert('An internal error occurred. Please check the developer console for details.');
    }
});
